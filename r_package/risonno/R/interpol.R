NULL

#' Resample ROI data to a regular multivariate time series.
#' 
#' This function computes average (arithmetic mean) of all recorded variables at regular intervals by windowing the time series.
#' Then, it performs linear interpolation in order to infer value of missing points. 
#'
#' @param d a datatable containing a time column (\code{d$t}) and one or several columns for recorded variables.
#' Typicaly, this would be generated by  \code{link{loadROIsFromFile}}.
#' @param fs the desired resampling frequency, in Hz.
#' @return A new data.table with the same columns as \code{d}.
#' @note The raw data is not guaranted to be a rugular time series in so far as 
#' 1. the exact time stamp of every raw data point depends on the performance of the acquisition device,
#' and 2. there could be missing data point when an animal is ocluded or not detected
#'
#' @examples
#' \dontrun{
#' FILE <- "result.db"
#' # Load the three first ROIs
#' ldfs <- loadROIsFromFile(FILE, rois=1:3)
#' ###### Simple example resampling the first ROI at 0.1Hz (i.e. every 10s):
#' d <- ldfs[roi_id == 2,]
#' new_d <- interpolateROIData(d, fs=0.1)
#' print(new_d)
#' }
#' @seealso \code{\link{loadROIsFromFile}} in order to load ROI data.
#' @export
interpolateROIData <- function(data, fs){
	d <- copy(data)
	ori_keys <- key(d)
	
	sampling_period <- 1/fs
	d[, t_round := sampling_period * round(d[,t] /sampling_period)]
	setkey(d, "t_round")

	# FIXME! make another mean primitive prototype
	d <- d[,lapply(.SD,mean),by=t_round]
	
	# all possible required output times
	t_out <- seq(from=d[1,t_round], to=d[.N,t_round], by=sampling_period)
	
	t_to_interpolate <- setdiff(t_out, d$t_round)
	
	to_interpolate_dt <- d[t_round==t_to_interpolate]
	
	missing_points <- lapply(d, interpolate, t=d[,t], t_out=t_to_interpolate)
	
	
	missing_points <- as.data.table(missing_points)
	missing_points[ , t_round := t_to_interpolate]
 	setkey(missing_points, "t_round")
 	d <- rbind(missing_points, d)
 	
	# we ensure the dt is time sorted
	d[,t:=t_round]
	setkey(d, "t")
	d$t_round <- NULL
	
	# we restitute old keys
	setkeyv(d, ori_keys)
	return(d)
}


interpolate <- function(t, yy, t_out){
	if(is.numeric(yy)){
		return(interp1(t, yy, t_out, "linear"))
	}
	
	else{
			yy <- as.factor(yy)
			levs <- levels(yy)
			yy <- unclass(yy)
			attr(yy, "levels") <- NULL
			out <- interp1(t, yy, t_out, "nearest")
			out <- as.factor(levs[out])
			return(out)
		}
}
